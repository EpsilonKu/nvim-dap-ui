#!/usr/bin/env python3.10
from __future__ import annotations

import json
import logging
import sys
from datetime import datetime
from enum import Enum
from typing import Any, List, Optional, Union

from pydantic import BaseModel, Extra, Field

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class Model(BaseModel):
    __root__: Any


class BaseTypes(Enum):
    URI = "URI"
    DocumentUri = "DocumentUri"
    integer = "integer"
    uinteger = "uinteger"
    decimal = "decimal"
    RegExp = "RegExp"
    string = "string"
    boolean = "boolean"
    null = "null"


class BooleanLiteralType(BaseModel):
    class Config:
        extra = Extra.forbid

    kind: str
    value: bool


class EnumerationEntry(BaseModel):
    class Config:
        extra = Extra.forbid

    documentation: Optional[str] = Field(None, description="An optional documentation.")
    name: str = Field(..., description="The name of the enum item.")
    proposed: Optional[bool] = Field(
        None,
        description="Whether this is a proposed enumeration entry. If omitted, the enumeration entry is final.",
    )
    since: Optional[str] = Field(
        None,
        description="Since when (release number) this enumeration entry is available. Is undefined if not known.",
    )
    value: Union[str, float] = Field(..., description="The value.")


class Name(Enum):
    string = "string"
    integer = "integer"
    uinteger = "uinteger"


class EnumerationType(BaseModel):
    class Config:
        extra = Extra.forbid

    kind: str
    name: Name


class IntegerLiteralType(BaseModel):
    class Config:
        extra = Extra.forbid

    kind: str = Field(
        ..., description="Represents an integer literal type (e.g. `kind: 1`)."
    )
    value: float


class Name1(Enum):
    URI = "URI"
    DocumentUri = "DocumentUri"
    string = "string"
    integer = "integer"


class MapKeyTypeItem(BaseModel):
    class Config:
        extra = Extra.forbid

    kind: str
    name: Name1


class MessageDirection(Enum):
    clientToServer = "clientToServer"
    serverToClient = "serverToClient"
    both = "both"


class MetaData(BaseModel):
    class Config:
        extra = Extra.forbid

    version: str = Field(..., description="The protocol version.")


class ReferenceType(BaseModel):
    class Config:
        extra = Extra.forbid

    kind: str
    name: str


class StringLiteralType(BaseModel):
    class Config:
        extra = Extra.forbid

    kind: str
    value: str


class TypeKind(Enum):
    base = "base"
    reference = "reference"
    array = "array"
    map = "map"
    and_ = "and"
    or_ = "or"
    tuple = "tuple"
    literal = "literal"
    stringLiteral = "stringLiteral"
    integerLiteral = "integerLiteral"
    booleanLiteral = "booleanLiteral"


class BaseType(BaseModel):
    class Config:
        extra = Extra.forbid

    kind: str
    name: BaseTypes


class Enumeration(BaseModel):
    class Config:
        extra = Extra.forbid

    documentation: Optional[str] = Field(None, description="An optional documentation.")
    name: str = Field(..., description="The name of the enumeration.")
    proposed: Optional[bool] = Field(
        None,
        description="Whether this is a proposed enumeration. If omitted, the enumeration is final.",
    )
    since: Optional[str] = Field(
        None,
        description="Since when (release number) this enumeration is available. Is undefined if not known.",
    )
    supportsCustomValues: Optional[bool] = Field(
        None,
        description="Whether the enumeration supports custom values (e.g. values which are not part of the set defined in `values`). If omitted no custom values are supported.",
    )
    type: EnumerationType = Field(..., description="The type of the elements.")
    values: List[EnumerationEntry] = Field(..., description="The enum values.")


class MapKeyType(BaseModel):
    __root__: Union[MapKeyTypeItem, ReferenceType] = Field(
        ...,
        description="Represents a type that can be used as a key in a map type. If a reference type is used then the type must either resolve to a `string` or `integer` type. (e.g. `type ChangeAnnotationIdentifier === string`).",
    )


class AndType(BaseModel):
    class Config:
        extra = Extra.forbid

    items: List[Type]
    kind: str


class ArrayType(BaseModel):
    class Config:
        extra = Extra.forbid

    element: Type
    kind: str


class MapType(BaseModel):
    class Config:
        extra = Extra.forbid

    key: MapKeyType
    kind: str
    value: Type


class MetaModel(BaseModel):
    class Config:
        extra = Extra.forbid

    enumerations: List[Enumeration] = Field(..., description="The enumerations.")
    metaData: MetaData = Field(..., description="Additional meta data.")
    notifications: List[Notification] = Field(..., description="The notifications.")
    requests: List[Request] = Field(..., description="The requests.")
    structures: List[Structure] = Field(..., description="The structures.")
    typeAliases: List[TypeAlias] = Field(..., description="The type aliases.")


class Notification(BaseModel):
    class Config:
        extra = Extra.forbid

    documentation: Optional[str] = Field(None, description="An optional documentation;")
    messageDirection: MessageDirection = Field(
        ...,
        description="The direction in which this notification is sent in the protocol.",
    )
    method: str = Field(..., description="The request's method name.")
    params: Optional[Union[Type, List[Type]]] = Field(
        None, description="The parameter type(s) if any."
    )
    proposed: Optional[bool] = Field(
        None,
        description="Whether this is a proposed notification. If omitted the notification is final.",
    )
    registrationMethod: Optional[str] = Field(
        None,
        description="Optional a dynamic registration method if it different from the request's method.",
    )
    registrationOptions: Optional[Type] = Field(
        None,
        description="Optional registration options if the notification supports dynamic registration.",
    )
    since: Optional[str] = Field(
        None,
        description="Since when (release number) this notification is available. Is undefined if not known.",
    )


class OrType(BaseModel):
    class Config:
        extra = Extra.forbid

    items: List[Type]
    kind: str


class Property(BaseModel):
    class Config:
        extra = Extra.forbid

    documentation: Optional[str] = Field(None, description="An optional documentation.")
    name: str = Field(..., description="The property name;")
    optional: Optional[bool] = Field(
        None,
        description="Whether the property is optional. If omitted, the property is mandatory.",
    )
    proposed: Optional[bool] = Field(
        None,
        description="Whether this is a proposed property. If omitted, the structure is final.",
    )
    since: Optional[str] = Field(
        None,
        description="Since when (release number) this property is available. Is undefined if not known.",
    )
    type: Type = Field(..., description="The type of the property")


class Request(BaseModel):
    class Config:
        extra = Extra.forbid

    documentation: Optional[str] = Field(None, description="An optional documentation;")
    errorData: Optional[Type] = Field(None, description="An optional error data type.")
    messageDirection: MessageDirection = Field(
        ..., description="The direction in which this request is sent in the protocol."
    )
    method: str = Field(..., description="The request's method name.")
    params: Optional[Union[Type, List[Type]]] = Field(
        None, description="The parameter type(s) if any."
    )
    partialResult: Optional[Type] = Field(
        None,
        description="Optional partial result type if the request supports partial result reporting.",
    )
    proposed: Optional[bool] = Field(
        None,
        description="Whether this is a proposed feature. If omitted the feature is final.",
    )
    registrationMethod: Optional[str] = Field(
        None,
        description="Optional a dynamic registration method if it different from the request's method.",
    )
    registrationOptions: Optional[Type] = Field(
        None,
        description="Optional registration options if the request supports dynamic registration.",
    )
    result: Type = Field(..., description="The result type.")
    since: Optional[str] = Field(
        None,
        description="Since when (release number) this request is available. Is undefined if not known.",
    )


class Structure(BaseModel):
    class Config:
        extra = Extra.forbid

    documentation: Optional[str] = Field(None, description="An optional documentation;")
    extends: Optional[List[Type]] = Field(
        None,
        description="Structures extended from. This structures form a polymorphic type hierarchy.",
    )
    mixins: Optional[List[Type]] = Field(
        None,
        description="Structures to mix in. The properties of these structures are `copied` into this structure. Mixins don't form a polymorphic type hierarchy in LSP.",
    )
    name: str = Field(..., description="The name of the structure.")
    properties: List[Property] = Field(..., description="The properties.")
    proposed: Optional[bool] = Field(
        None,
        description="Whether this is a proposed structure. If omitted, the structure is final.",
    )
    since: Optional[str] = Field(
        None,
        description="Since when (release number) this structure is available. Is undefined if not known.",
    )


class StructureLiteral(BaseModel):
    class Config:
        extra = Extra.forbid

    documentation: Optional[str] = Field(None, description="An optional documentation.")
    properties: List[Property] = Field(..., description="The properties.")
    proposed: Optional[bool] = Field(
        None,
        description="Whether this is a proposed structure. If omitted, the structure is final.",
    )
    since: Optional[str] = Field(
        None,
        description="Since when (release number) this structure is available. Is undefined if not known.",
    )


class StructureLiteralType(BaseModel):
    class Config:
        extra = Extra.forbid

    kind: str
    value: StructureLiteral


class TupleType(BaseModel):
    class Config:
        extra = Extra.forbid

    items: List[Type]
    kind: str


class Type(BaseModel):
    __root__: Union[
        BaseType,
        ReferenceType,
        ArrayType,
        MapType,
        AndType,
        OrType,
        TupleType,
        StructureLiteralType,
        StringLiteralType,
        IntegerLiteralType,
        BooleanLiteralType,
    ]


class TypeAlias(BaseModel):
    class Config:
        extra = Extra.forbid

    documentation: Optional[str] = Field(None, description="An optional documentation.")
    name: str = Field(..., description="The name of the type alias.")
    proposed: Optional[bool] = Field(
        None,
        description="Whether this is a proposed type alias. If omitted, the type alias is final.",
    )
    since: Optional[str] = Field(
        None,
        description="Since when (release number) this structure is available. Is undefined if not known.",
    )
    type: Type = Field(..., description="The aliased type.")


AndType.update_forward_refs()
ArrayType.update_forward_refs()
MapType.update_forward_refs()
MetaModel.update_forward_refs()
Notification.update_forward_refs()
OrType.update_forward_refs()
Property.update_forward_refs()
Request.update_forward_refs()
Structure.update_forward_refs()
TupleType.update_forward_refs()


class Generator:
    def __init__(self, model: MetaModel) -> None:
        self.model = model
        self.known_objs: dict[str, Structure | TypeAlias] = {}
        self.known_literals: dict[int, Structure] = {}

    def register(
        self, obj: Structure | TypeAlias | StructureLiteral
    ) -> Structure | TypeAlias:
        if isinstance(obj, StructureLiteral):
            if id(obj) not in self.known_literals:
                self.known_literals[id(obj)] = Structure(
                    name=f"Structure{len(self.known_literals)}",
                    documentation=obj.documentation,
                    properties=obj.properties,
                    proposed=obj.proposed,
                    since=obj.since,
                    extends=[],
                    mixins=[],
                )
            obj = self.known_literals[id(obj)]
        logger.info(f"Registering {obj.name}")
        if obj.name not in self.known_objs:
            self.known_objs[obj.name] = obj
        return obj

    def convert_method_name(self, name: str) -> str:
        return name.replace("/", "_").replace("$", "_")

    def type_prefix(self) -> str:
        return "dapui.async.lsp.types"

    def structure_name(self, orig_name: str) -> str:
        return f"{self.type_prefix()}.{orig_name}"

    def kind_name(self, orig_name: str) -> str:
        return f"{self.type_prefix()}.{orig_name.title()}"

    def and_type(self, items: list[ReferenceType]) -> Structure:
        sub_structure = Structure(
            name="And".join(t.name for t in items),
            documentation="",
            extends=[Type(__root__=t) for t in items],
            properties=[],
            mixins=[],
            proposed=None,
            since=None,
        )
        return sub_structure

    def key_name_type(self, name: Name1) -> str:
        match name:
            case Name1.URI:
                return f"{self.type_prefix()}.URI"
            case Name1.DocumentUri:
                return f"{self.type_prefix()}.DocumentURI"
            case Name1.string:
                return "string"
            case Name1.integer:
                return "integer"
            case _:
                raise NotImplementedError(name)

    def type_name(self, type_: Type | MapKeyType) -> str:
        root = type_.__root__
        if isinstance(root, AndType) and root.kind != TypeKind.and_.value:
            root = OrType(kind=TypeKind.or_.value, items=root.items)
        match root:
            case BaseType(name=name):
                match name:
                    case BaseTypes.integer | BaseTypes.uinteger:
                        return "integer"
                    case BaseTypes.decimal:
                        return "number"
                    case BaseTypes.string:
                        return "string"
                    case BaseTypes.URI:
                        return self.key_name_type(Name1.URI)
                    case BaseTypes.DocumentUri:
                        return self.key_name_type(Name1.DocumentUri)
                    case BaseTypes.boolean:
                        return "boolean"
                    case BaseTypes.null:
                        return "nil"
            case ReferenceType(name=name):
                return self.structure_name(name)
            case ArrayType(element=element):
                return f"{self.type_name(element)}[]"
            case MapType(key=key, value=value):
                match key.__root__:
                    case ReferenceType():
                        return f"table<{self.type_name(key)}, {self.type_name(value)}>"
                    case MapKeyTypeItem(name=name):
                        return f"table<{self.key_name_type(name)}, {self.type_name(value)}>"
            case AndType(items=items):
                refs = [
                    t.__root__ for t in items if isinstance(t.__root__, ReferenceType)
                ]
                if len(items) > len(refs):
                    others = [t for t in items if t.__root__ not in refs]
                    logger.warning(
                        f"Discarding non-reference/literal types from AndType {others}"
                    )
                struc = self.and_type(refs)
                self.register(struc)
                return self.structure_name(struc.name)
            case OrType(items=items):
                return "|".join(self.type_name(item) for item in items)
            case TupleType(items=items):
                return ",".join(self.type_name(item) for item in items)
            case StructureLiteralType(value=value):
                struc = self.register(value)
                return self.structure_name(struc.name)
            case StringLiteralType(value=value):
                return f"'{value}'"
        raise NotImplementedError(root)

    def prepare_doc(self, doc: str, multiline: bool) -> list[str]:
        lines = doc.strip().splitlines()
        if multiline:
            return [f"--- {line.strip()}" for line in lines]
        return [" ".join(line.strip() for line in lines)]

    def structure(self, structure: Structure) -> list[str]:
        lines = [""]
        if structure.documentation:
            lines.extend(self.prepare_doc(structure.documentation, multiline=True))

        lines.append(f"---@class {self.structure_name(structure.name)}")
        if structure.extends or structure.mixins:
            lines[-1] += " : " + ",".join(
                self.type_name(t)
                for t in [*(structure.extends or []), *(structure.mixins or [])]
            )
        for prop in structure.properties:
            line = f"---@field {prop.name}{'?' if prop.optional else ''} {self.type_name(prop.type)}"
            if prop.documentation:
                line = f"{line} {self.prepare_doc(prop.documentation, False)[0]}"
            lines.append(line)
        return lines

    def type_alias(self, type_alias: TypeAlias) -> list[str]:
        self.register(type_alias)
        return [
            f"---@alias {self.type_prefix()}.{type_alias.name} {self.type_name(type_alias.type)}"
        ]

    def request(self, request: Request) -> list[str]:
        lines = []
        if request.documentation:
            lines += self.prepare_doc(request.documentation, True)

        lines.append("---@async")
        lines.append(f"---@param bufnr integer Buffer number (0 for current buffer)")
        if request.params:
            lines.append(f"---@param args {self.type_name(request.params)}")
        lines.append(f"---@param opts? dapui.async.lsp.RequestOpts Options for the request handling")
        if request.result:
            lines.append(f"---@return {self.type_name(request.result)}")

        lines.append(
            f"function LSPRequestClient.{self.convert_method_name(request.method)}(bufnr {',args' if request.params else ''}, opts) end"
        )
        lines.append("")
        return lines

    def notification(self, notification: Notification) -> list[str]:
        lines = []
        if notification.documentation:
            lines += self.prepare_doc(notification.documentation, True)

        lines.append("---@async")
        if notification.params:
            lines.append(f"---@param args {self.type_name(notification.params)}")
        lines.append(
            f"function LSPNotifyClient.{self.convert_method_name(notification.method)}({'args' if notification.params else ''}) end"
        )
        lines.append("")
        return lines

    def enumeration(self, enum: Enumeration) -> list[str]:
        lines = []
        if enum.documentation:
            lines += self.prepare_doc(enum.documentation, True)
        lines.append(
            f"---@alias {self.type_prefix()}.{enum.name} {'|'.join(json.dumps(val.value) for val in enum.values)}"
        )
        lines.append("")
        return lines

    def generate(self):
        lines = [
            f"---Generated on {datetime.utcnow()}",
            "",
            "---@class dapui.async.lsp.RequestClient",
            "local LSPRequestClient = {}",
            "---@class dapui.async.lsp.RequestOpts",
            "---@field timeout integer Timeout of request in milliseconds"
            "",
        ]
        for obj in self.model.structures + self.model.typeAliases:
            self.register(obj)
        for request in self.model.requests:
            if request.messageDirection == MessageDirection.clientToServer:
                logger.info(f"Generating request {request.method}")
                lines.extend(self.request(request))
        lines.extend(
            [
                "---@class dapui.async.lsp.NotifyClient",
                "local LSPNotifyClient = {}",
                "",
            ]
        )
        for notification in self.model.notifications:
            if notification.messageDirection == MessageDirection.clientToServer:
                logger.info(f"Generating notification {notification.method}")
                lines.extend(self.notification(notification))
        for enum in self.model.enumerations:
            logger.info(f"Generating enumeration {enum.name}")
            lines.extend(self.enumeration(enum))
        lines.extend(
            [
                f"---@alias {self.key_name_type(Name1.URI)} string",
                f"---@alias {self.key_name_type(Name1.DocumentUri)} string",
            ]
        )

        for obj in [*self.known_objs.values()]:
            if isinstance(obj, Structure):
                self.structure(obj)
            else:
                self.type_alias(obj)

        for obj in [*self.known_objs.values()]:
            if isinstance(obj, Structure):
                self.structure(obj)
            else:
                self.type_alias(obj)
        for obj in self.known_objs.values():
            logger.info(f"Generating structure {obj.name}")
            if isinstance(obj, Structure):
                lines.extend(self.structure(obj))
            else:
                lines.extend(self.type_alias(obj))
        return lines


model = MetaModel.parse_file("lsp.json")
lines = Generator(model).generate()
sys.stdout.write("\n".join(lines))
